<!DOCTYPE html>

<!--
  Google HTML5 slide template

  Authors: Luke Mahé (code)
           Marcin Wichary (code and design)
           
           Dominic Mazzoni (browser compatibility)
           Charles Chen (ChromeVox support)

  URL: http://code.google.com/p/html5slides/

  URL:
-->

<html>
  <head>
    <title>It's React Time!</title>

    <meta charset='utf-8'>

    <!-- Main JS file from html5slides project, you should probably don't touch it -->
    <script src="resources/libs/slides.js"></script>
    <!-- jQuery - it's not required, if you don't need it - remove it -->
    <script src="resources/libs/jquery.js"></script>

    <!-- Main CSS file from html5slides project - again, don't touch this stuff -->
    <link rel="stylesheet"  href='resources/styles.css'>
    <!-- Some nice icons - check them out: http://shoestrap.org/downloads/elusive-icons-webfont/ -->
    <link rel="stylesheet" href="resources/elusive-webfont/css/elusive-webfont.css">
    <!-- Making Waves specific styles -->
    <link rel="stylesheet" href="resources/custom.css">
  </head>

  <body style='display: none'>

    <!-- This is main container, you can change presentation layout by changing layout-regular to layout-faux-widescreen or layout-widescreen.-->
    <section class='slides layout-regular'>

      <!-- Title slide -->
      <article class="title_slide">
        <h1>It's React Time</h1>
        <h2>Wprowadzenie w podstawy React</h2>

        <br />
        <br />
        <p>https://git.io/Je9M1</p>
        <div class="title_info">
          Prowadzące:
          <br />
          Ewa Turska
          <br />
          Jadzia Przebinda
          <br />
          <span class="small">Grudzień 2019</span> 
        </div>
      </article>

      <article>
        <h3>Wymagania</h3>
        <p>Zainstalowane: <strong>node</strong> oraz <strong>npm</strong></p>
        <br />
        <br />
        <h3>Tworzenie projektu</h3>
        <p>npx create-react-app <strong>&lt;nazwa-projektu&gt;</strong></p>
        <p>npm start</p>
      </article>

      <article>
        <h3>Komponenty</h3>
        <p>Każdy komponent Reactowy musi zawierać:</p>
        <pre>
          import React from "react";        </pre>
        <p>Zazwyczaj "główny" plik JS-owy to index.js, który wygląda w ogólnym zarysie tak:</p>
        <pre>
          import React from "react";
          import ReactDOM from 'react-dom';

          import App from './components/App';

          ReactDOM.render(
              &lt;App /&gt;,
              document.querySelector('#root')
          );        </pre>
        <p>gdzie:</p>
        <ul>
          <li><code>import ReactDOM from 'react-dom';</code> jest potrzebne tylko wtedy, gdy korzystamy z <code>ReactDOM.render()</code></li>
          <li><code>ReactDOM.render</code> jako pierwszy parametr przyjmuje nasz główny komponent <strong>App</strong>, a jako drugi identyfikator kontenera, w jakim chcemy osadzić naszą aplikację</li>
        </ul>
      </article>
      <article>
        <h3>Function based component</h3>
        <pre>
          const App = function() {
              return &lt;div&gt;Hi there!&lt;/div&gt;
          }          </pre>
        <p>lub</p>
        <pre>
          const App = () => {
              return &lt;div&gt;Hi there!&lt;/div&gt;
          }            </pre>
        <ul>
          <li>nie ma tu metody <code>render</code>, zamiast metod cyklu życia używa się tzw. "hooków"</li>
          <li><strong>state</strong> jest definiowany za pomocą hook'a <code>useState</code></li>
          <li>W <code>return ()</code> znajduje się to, co komponent ma "narysować"</li>
        </ul>
        <p><br /><br />Powyższe informacje są bardzo ogólnikowe, jako że na warsztatach uczymy się używać komponentów klasowych.</p>
      </article>
      <article>
        <h3>Class based component</h3>
        <pre>
          import React from "react";
          class App extends React.Component {
            render() {
              return &lt;div&gt;Hi there!&lt;/div&gt;
            }
          }              
          export default App;</pre>
        <pre>
          import React, {Component} from "react";
          class App extends Component {          
            render() {
              return &lt;div&gt;Hi there!&lt;/div&gt;
            }
          }
          export defauult App;</pre>
          <p>Powyższe zapisy różnią się tylko tym, jak korzystamy z <code>React.Component</code>. </p>
          <p>W komponentach klasowych metodą odpowiadającą za "rysowanie" komponentu jest <code>render()</code>. Oprócz tego mamy dostęp do metod cyklu życia (o czym później).</p>
      </article>

      <article>
        <h3>JSX</h3>
        <ul>
          <li>Pozornie wygląda bardzo znajomo jak HTML, jednak nie jest to HTML :)</li>
          <li>Przeglądarki nie rozumieją JSX - potrzebny jest Babel do kompilacji. Korzystając z <strong>create-react-app</strong> nie martwimy się tym - paczka ma już skonfigurowanego webpacka z babelem</li>
          <li>Jest wygodny w używaniu i ułatwia rozumienie/czytanie kodu</li>
          <li>Nie musicie go używać, ale jest rekomendowany</li>
          <li>zawiera komponenty oraz JS-ową logikę</li>
          <li>żeby "jawnie" pokazać, że korzysta się z JSXa, używa się nawiasów okrągłych <code><strong>(</strong>&lt;div&gt;Witaj świecie!&lt;/div&gt;<strong>)</strong></code></li>
          <li>by poinformować kompilator, że w JSXie schce się skorzystać z logiki JS-owej bądź wyświetlić wartość zmiennej, należy użyć nawiasów klamrowych <code>(&lt;div&gt;Witaj <strong>{</strong>name<strong>}</strong>!&lt;/div&gt;)</code></li>
        </ul>
      </article>

      <article>
        <h3>Props</h3>
        <div style="position: relative;">
        <p class="pre-label">Plik List.js</p>
        <pre>

          class List extends React.Component {
            render() {
              return (
                &lt;div&gt;
                  &lt;p&gt;{this.props.<strong>title</strong>}}&lt;/p&gt;
                  &lt;ul className=“list”&gt; 
                    {this.props.<strong>list</strong>.map(element => &lt;li key={element.id}&gt;{element.name}}&lt;/li&gt;)}
                  &lt;/ul&gt;
                &lt;/div&gt;
              )
            }
          }
          export default List;
        </pre>
        </div>
        <div style="position: relative;">
        <p class="pre-label">Plik App.js</p>
        <pre>

          import List from "./components/List.js"
          class App extends React.Component {
            render() {
              return  (
                &lt;List <strong>title</strong>="Lista rzeczy do kupienia" <strong>list</strong>={[{id:1, name:"Przedmiot 1"}, {id:2, name:"Przedmiot 2"}]}/&gt;
              );
            }
          }              
        </pre>
        </div>
      </article>

      <article>
        <h3>Props</h3>
        <ul>
          <li><strong>Propsami</strong> nazywamy te wartości, które przekazujemy komponentowi jako atrybuty. </li>
          <li>Do wartości propsa dostajemy się poprzez <code>this.props.<strong>nazwa_atrybutu</strong></code> - tak jak na poprzednim slajdzie widzimy:
          komponent <code>List</code> dostaje tablicę jako atrybut <code>list</code> oraz tekst jako atrybut <code>title</code>. Możemy się do nich dostać
          wewnątrz komponentu poprzed odwołanie się do <code>this.props.list</code> oraz <code>this.props.title</code>.</li>
          <li>Gdy do wyświetlania listy korzystamy z <code>map</code>, musimy pamiętać, że każdy element/komponent zwracany przez <code>map</code> musi mieć ustawiony atybut <code>key</code>.
          <code>Key</code> musi posiadać unikalną wartość - najczęściej jest to <strong>id</strong>.</li>
          <li>Nie zaleca się ustawiania jako <code>key</code> kolejnej wartości iteracji - używana tablica może być tylko posortowana inaczej, co powoduje,
          że wcześniejsze indeksy iteracji odpowiadają teraz innym elementom, przez co React przerenderuje wszystkie elementy, zamiast tylko te, które się zmieniły.</li>
        </ul>
      </article>
      <article>
        <h3>Props - przykład</h3>
        <table>
          <tr>
            <th>Sortowanie wg ceny</th>
            <th>Sortowanie wg nazwy</th>
          </tr>
          <tr>
            <td><pre>list = [{id: 1, name: "gruszka", price: 2},
        {id: 2, name: "jabłko", price: 2},
        {id: 3, name: "banany", price: 5},
        {id: 4, name: "kaki", price: 7}]</pre></td>
            <td><pre>list = [{id: 3, name: "banany", price: 5},
        {id: 1, name: "gruszka", price: 2},
        {id: 2, name: "jabłko", price: 2},
        {id: 4, name: "kaki", price: 7}]</pre></td>
          </tr>
        </table>
        <table>
            <tr>
              <th>Id jako key</th>
              <th>Indeks iteracji jako key</th>
            </tr>
            <tr>
              <td><pre>list.map( (element) => (
    &lt;li key={element.id}&gt;name: {element.name}, price: {element.price}&lt;/li&gt
  )
)</pre></td>
              <td><pre>list.map( (element, index) => (
    &lt;li key={index}&gt;name: {element.name}, price: {element.price}&lt;/li&gt
  )
)</pre></td>
            </tr>
          </table>
          <p>React tworzy sobie tzw. <strong>Virtual DOM</strong>, 
          na podstawie którego renderuje drzewo DOM w przeglądarce. Gdy się coś zmienia to tworzy nowy Virtual DOM, porównuje go 
        z poprzednim i na podstawie różnic decyduje, które elementy w drzewie DOM powinny się zmienić. Gdy jako key używamy np. id, React wie,
      że zmieniła się tylko kolejność komponentów, zatem nie musi ich na nowo tworzyć w pamięci - może je tylko ustawić we właściwej kolejności.
     Gdy korzystamy z indeksu iteracji, dla Reacta wszystkie albo prawie wszystkie komponenty (u nas <code>li</code>) się zmieniły - bo mają inne 
    identyfikatory - zatem musi je na nowo utworzyć i wstawić do drzewa DOM, co nie jest optymalnym rozwiązaniem.</p>
      </article>
      
      <article>
        <h3>State</h3>
        <pre>
            class SearchBar extends React.Component {
              state = {
                  phrase: ""
              }          
              onInputChange = (event) => {
                  this.setState({
                      phrase: event.target.value
                  });
              }
              render() {
                  return (
                      &lt;form&gt;
                          &lt;label&gt;{this.props.label}&lt;/label&gt;
                          &lt;input 
                              type="text" 
                              value={this.state.phrase}
                              onChange={this.onInputChange}
                          /&gt;
                          &lt;div&gt;Result word is: {this.state.phrase}&lt;/div&gt;
                      &lt;/form&gt;
                  )
              }
          } </pre>
      </article>

      <article>
        <h3>Renderowanie komponentów</h3>
        <pre>
          class App extends React.Component {
            <strong>getDescription()</strong> = () => {
              return ‘Lista zakupów na dzisiejszą kolację’;
            }
            render() {
              return ( 
                &lt;div style=<strong>{{marginTop:</strong> 20px;<strong>}}</strong>&gt;
                  &lt;p&gt;<strong>{getDescription()}</strong>&lt;/p&gt;
                  &lt;ul <strong>className</strong>="list"&gt;
                    &lt;li&gt;{this.props.list[0].name}&lt;/li&gt;
                    &lt;li&gt;{this.props.list[1].name}&lt;/li&gt;
                  &lt;/ul&gt;
                &lt;/div&gt;
              )
            }
          }</pre>
      </article>
      <article>
        <h3>Life cycle methods</h3>
        <pre>

          class App extends React.Component {
            componentDidMount() {
              ...
            }

            componentDidUpdate(prevProps) {
              ...
            }

            componentWillUnmount() {
              ...
            }
          }
        </pre>
      </article>

      <article>
        <h3>Stylowanie inline</h3>
        <pre>

          class App extends React.Component {
            render() {
              return (
                &lt;div
                  style={{
                    backgroundColor: lightblue,
                    marginTop: 36
                  }}
                &gt;
                  &lt;h1
                    style={{
                      fontFamily: "Helvetica, sans-serif"
                    }}
                  &gt;
                    Lista przedmiotów
                  &lt;/h1&gt;
                  &lt;ul&gt;
                    &lt;li&gt;Przedmiot 1&lt;/li&gt;
                    &lt;li&gt;Przedmiot 2&lt;/li&gt;
                  &lt;/ul&gt;
                &lt;/div&gt;
              )
            }
          }
        </pre>
      </article>

      <article>
        <h3>Stylowanie inline</h3>
        <pre>

          const styles = {
            container : {
              backgroundColor: lightblue,
              marginTop: 36
            },
            title : {
              fontFamily: "Helvetica, sans-serif"
            }
          }

          class App extends React.Component {
            render() {
              return (
                &lt;div style={styles.container}&gt;
                  &lt;h1 style={styles.title}&gt;
                    Lista przedmiotów
                  &lt;/h1&gt;
                  &lt;ul&gt;
                    &lt;li&gt;Przedmiot 1&lt;/li&gt;
                    &lt;li&gt;Przedmiot 2&lt;/li&gt;
                  &lt;/ul&gt;
                &lt;/div&gt;
              )
            }
          }
        </pre>
      </article>
      <article>
        <h3>Stylowanie inline - problemy</h3>
        <ul>
          <li>duplikacja wartości</li>
          <li>brak wsparcia dla pseudoklas</li>
          <li>brak wsparcia dla media queries</li>
          <li>brak wsparcia dla keyframes</li>
        </ul>

        <pre>
          //plik ze zmiennymi

          const baseMargin = '36';
          const smallMargin = '20';
          export default {
            baseMargin,
            smallMargin,
          };
        </pre>
      </article>

      <article>
        <h3>Stylowanie - biblioteki CSS-in-JS</h3>
        <ul>
            <li>Styled Components</li>
            <li>Aphrodite</li>
            <li>Radium</li>
            <li>JSS</li>
            <li>Emotion</li>
          </ul>
      </article>
      <article>
        <h3>Stylowanie - CSS Modules</h3>
        <pre>
          //plik App.module.css
          .Container {
            background-color: lightblue;
            margin-top: 36px;
          }

          .Title {
            fontFamily: Helvetica, sans-serif;
          }
        </pre>
        <pre>
          //plik App.js
          import styles from "./App.module.css";
          class App extends React.Component {
            render() {
              return (
                &lt;div className={styles.Container}&gt;
                  &lt;h1 className={styles.Title}&gt;To jest tytuł&lt;/h1&gt;
                &lt;/div&gt;
              )
            }
          }
        </pre>
        <p>Klasy, które zobaczymy w inspektorze, to np. <code>_src_App_module__Container</code>, <code>_src_App_module__Title</code></p>
      </article>



      <!-- Thank you slide -->
      <article class='thank_you_slide'>
        <h1>Dziękujemy!</h1>
      </article>

    </section>

    <script>
        (function() {
            //makes all links open in a separate tab/window
            var allLinks = document.querySelectorAll('body a');
            for(var i= 0, l=allLinks.length; i<l; i++){
                allLinks.item(i).setAttribute('target', '_blank');
            }
        })();
    </script>
  </body>
</html>